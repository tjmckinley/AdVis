--- 
title: "Advanced Visualisation and Data Wrangling in R"
author: "TJ McKinley"
site: bookdown::bookdown_site
output:
    bookdown::gitbook:
        config:
            sharing: null
        css: 'style.css'
        includes:
            in_header: _toggle.html
    bookdown::pdf_book:
        keep_tex: yes
        includes:
            in_header: header.tex
linkcolor: blue
documentclass: book
link-citations: yes
---

# Introduction {-}

```{r, child = "_setup.Rmd", include = F, purl = F, cache = F}
```

In this workshop we will introduce some R packages that provide really useful and powerful functions for doing visualisation of complex data sets. We will see how R can be used to make informative animations, and even interactive HTML graphics.

## Tasks {-}

```{task}
All **tasks** will be denoted in panel boxes like this one. In the HTML version, all solutions can be toggled by hitting the **Show Solution** buttons. In the PDF version solutions are given in the Appendix and are linked via the **Show Solution** buttons.
```

```{solution}
Eloquent and inspiring solution.
```

<!--chapter:end:index.Rmd-->

# Advanced Visualisation

In the next couple of practicals we will introduce you to some really useful packages for data wrangling and visualisation: notably [`tidyr`](https://cran.r-project.org/web/packages/tidyr/), [`dplyr`](https://cran.r-project.org/web/packages/dplyr/index.html) and [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html). We start with a motivating example.

## Gapminder

[Professor Hans Rosling](https://en.wikipedia.org/wiki/Hans_Rosling) has made a name for himself in the field of data visualisation with his groundbreaking [Gapminder](https://www.gapminder.org/) project. 

```{r, screenshot.alt = "images/hans.jpg", align = "center", echo = F}
include_url("https://www.youtube.com/embed/jbkSRLYSojo")
```

For a slightly longer presentation, his TED talk on global development has been watched over 11 million times. If you have 20 minutes, it can be found [here](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen?utm_source=tedcomshare&utm_medium=referral&utm_campaign=tedspread), and is well worth a watch!

> **Update**: More-or-less as I finished these practical notes, the news broke that Professor Rosling had sadly passed away on 7th February 2017, aged 68. I hope you will find some time to explore the [Gapminder](https://www.gapminder.org/) website, and appreciate the contribution that he made to the world of public health and education. He presented a world-view based on facts and data; to this end he provided innovative and fascinating ways to explore and understand data, disseminated these findings with pathos and humour, and used this information to challenge many of our pre-conceptions about public health and the developing world. An obituary from the Guardian can be found [here](https://www.theguardian.com/global-development/2017/feb/07/hans-rosling-obituary).

The [Gapminder](https://www.gapminder.org/) website provides really informative interactive visualisations for many fascinating data sets. In this pracical we will explore how to use R to try to recreate something similar to the types of visualisation that Gapminder provides, and see how high-end R packages have been developed that provide a systematic and flexible way to generate complex plots / visualisations from data. We will begin by trying to emulate the plot in Figure \@ref(fig:gapminder).

We will do this first by using R's base graphics system, before introducing a set of functions from a powerful package called [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html).

### Gapminder data

Datasets from the Gapminder project can be downloaded from [https://www.gapminder.org/data](https://www.gapminder.org/data). However, this particular data set is available in a package in R called (naturally) [`gapminder`](https://cran.r-project.org/web/packages/gapminder/index.html). This can be installed in the usual way. (For ease later on, make sure the `tidyr`, `dplyr` and `ggplot2` packages are also installed.)

```{r, eval = F}
install.packages("gapminder")
install.packages("tidyr")
install.packages("tibble")
install.packages("dplyr")
install.packages("ggplot2")
```

Once you have it installed we need to load the packages. 

```{r, cache = F, message = F}
library(gapminder)
library(tidyr)
library(tibble)
```

> Two really useful cheat sheets to have for data wrangling can be found [here](https://www.rstudio.com/resources/cheatsheets/), under [Data Import Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-import-cheatsheet.pdf) and [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-transformation-cheatsheet.pdf).

To have a quick look at the data, which are available as an object called `gapminder`. We can use the `head()` and `tail()` functions, which print the top and bottom of a data frame respectively. The functions `dim()` and `summary()` are also useful e.g.

```{r}
dim(gapminder)
head(gapminder)
tail(gapminder)
summary(gapminder)
```

Here we can see that the data set consists of `r nrow(gapminder)` rows and `r ncol(gapminder)` columns, and contains information on country, continent, life expectancy, population size, GDP (per capita) and year.

> **Aside**: Note the slightly strange formatting when printing the `data.frame`. This is subtly different to what you've seen before. This is because the `gapminder` data is actually a `tbl` object (pronounced "tibble"), which is a special object type. This is an enhanced `data.frame` object: `tbls` are generally easier to examine than `data.frames`, for example they force R to display only the data that fits onscreen. It also adds some information about the class of each column. Try typing
> ```{r}
> gapminder
> ```
> to see what I mean. In fact, the `tibble` package introduces the `as_tibble()` function to convert ordinary `data.frame` objects to `tbls` in case you want to use this functionality in future. Please see the [Data Import Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-import-cheatsheet.pdf) for more information.
>  
>  Note also that `tbl` seems to make a distinction between integers (`<int>`) and doubles (`<dbl>`), instead of just using `numeric`. R makes no such distinction in practice, and so you can think of either of these as simply `numeric` types.

Let's just clarify the data:

* **`country`**: country of interest (`factor`);
* **`continent`**: continent country can be found in (`factor`);
* **`year`**: year corresponding to data (in increments of 5 years) (`numeric`);
* **`lifeExp`**: life expectancy at birth (in years) (`numeric`);
* **`pop`**: population size (`numeric`);
* **`gdpPercap`**: GDP per capita, in dollars, by Purchasing Power Parities and adjusted for inflation (`numeric`).

<!--chapter:end:ch_adVis.Rmd-->

# Visualisation (the old-fashioned way)

R's base graphics system is very flexible, and is one of the main reasons R has surged in popularity amongst statisticians and data scientists. Flexibility often comes with a price, and in this case it's that complex plotting often involves many steps. Here I will take you through a process of building a complex plot up piece-by-piece using R's base graphics system.

> Please note there are other ways to do this, you might find a better way!

Let's start by visualising a single year, and noting that we are trying to produce something that looks like Figure \@ref(fig:gapminder).

```{r, gapminder, fig.cap = "Life expectancy against GDP---screenshot from Gapminder project"}
include_graphics("images/gapminder.png")
```

Let's break this plot down into various **features**:

* It shows data from 1952 only;
* it shows a **scatterplot** of  **life expectancy** on the $y$-axis, and **GDP per capita** on the $x$-axis;
* GDP is plotted on the **$\log_{10}$** scale;
* points are coloured according to **continent**;
* points are scaled according to the population of the country (more subtly---they are scaled according to **area**, so a point with *double the area* of another point, has *twice the population*).

Let's start by extracting just the subset of data from 1952 to work with, and save this into a new object called `gpm1952`:

```{r}
gpm1952 <- gapminder[gapminder$year == 1952, ]
gpm1952
```

Let's start by producing a straightforward scatterplot of life expectancy against GDP.

```{r}
plot(gpm1952$gdpPercap, gpm1952$lifeExp)
```

OK, so we have a basic plot of life expectancy against GDP for the year 1952, but it's a bit uninformative. Let's start by trying to implement some of the features discussed above, beginning by plotting GDP on the $\log_{10}$ scale, using R's `log10()` function:

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp)
```

That's a bit better. Now lets think about colours. Each row of the `gapminder` data has an associated `continent` value, and the `continent` column is a `factor` with `r length(levels(gapminder$continent))` levels e.g.

```{r}
levels(gapminder$continent)
```

Remember, when we convert a `factor` to a `numeric`, it replaces the factor level with its position in the hierarchy of `levels()`. Hence in this example ` `r levels(gapminder$continent)[1]` ` gets replaced by `1`; ` `r levels(gapminder$continent)[2]` ` gets replaced by `2` and so on (see Practical 1 for a recap). So,

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     col = as.numeric(gpm1952$continent))
```

This is looking a bit better, but ideally we would like filled points with black borders. This can be done by setting the point character, `pch = 21`. This allows for a circle with different coloured background and border. By default, the `col` argument sets the **border** of the circle, and the `bg` argument sets the **background** colour. Since the default `col` is `"black"`, we only have to set the `bg` argument.

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent))
```

> **Aside**: a nice graphical look at R's base point characters and line types can be found [here](http://www.statmethods.net/advgraphs/parameters.html).

OK, so we're making some progress. Let's try scaling the points to reflect population size. The `cex` argument to the `plot()` function stands for **character expansion**, so perhaps linking the vector of population sizes to this argument will scale the point sizes accordingly. Before we do this we need to note that the ***scale*** of population sizes are huge, so perhaps it's sensible to scale by **relative** population size (hence if we divide all population sizes by the maximum population size, we will force the population sizes to be in the range $[0, 1]$) e.g.

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = gpm1952$pop / max(gpm1952$pop))
```

> **Tip**: If you're unsure of what each of the lines is doing above, try copying-and-pasting parts into the console. For example (I've only printed the first six entries for brevity):
> ```{r}
> head(gpm1952$pop)
> max(gpm1952$pop)
> head(gpm1952$pop / max(gpm1952$pop))
> ```
> We can see that this produces a vector of scaled population sizes in the range $[0, 1]$.

Hmmm. We seem to have different point sizes, but many points are *very* small. This is because the **maximum point size** is one, so perhaps multiplying by a scalar will help to improve matters. Let's choose to multiply by 10:

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = 10 * gpm1952$pop / max(gpm1952$pop))
```

This is still not quite right compared to Figure \@ref(fig:gapminder). Ah! We should note that character expansion using the `cex` argument scales points **linearly** (hence it increases both $x$ and $y$ dimensions by a fixed amount). In this case we have a circle, and so linearly scaling the circle is the same as mutiplying by the **radius**, and not the **area**, as we originally wanted. We know that if $A$ is the area of a circle, then $A = \pi r^2$, where $r$ is the radius. As a result, to scale the *area* $A$ by some value $s_A$, this is equivalent to scaling the *radius* by some value $s_r$, where
$$
    \begin{aligned}
    s_A A &= \pi \left(rs_r\right)^2\\
    \sqrt{\frac{s_A A}{\pi}} &= rs_r\\
    s_r &= \frac{\sqrt{s_A A}}{r\sqrt{\pi}}.
    \end{aligned}
$$
Since we do not know the radius of a circle `pch = 21` at its default point size, we cannot scale by exact area (which wouldn't make sense in any case since the two axes are on different scales), but we can at least keep the *relative* areas fixed between points. (Alternatively, we could use the `symbols()` function, which allows us to add circles to a plot scaled by an appropriate radius.)

Hence, if $A$ is the area of the largest point (at the default point size), and instead we want the largest point to have an area of $s_A A$, then this means scaling the radius of all points by $\sqrt{s_A / \pi}$. (R provides a constant `pi` to equal $\pi$.) Here I played around a bit and found that setting $s_A = 200$ worked well.
    
```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))))
```

This is looking a bit better. Now the points are scaled by relative area.

Now let's think about tidying up the axes. Firstly the axis titles and main title:

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))),
     xlab = "log10(GDP per capita)",
     ylab = "Life expectancy at birth (years)",
     main = "1952")
```

Not far off! Although the $x$-axis is correct, it is sometimes more informative to change the axis labels to reflect the actual GDP values (for example, a value of 5 is hard to decipher in terms of real-life numbers, since it's on the log-scale, but a value of $10^5 = 100,000$ is arguably more informative). To do this, we have to first tell R to leave off the $x$-axis when plotting (using the `xaxt = "n"` argument), and then use the `axis()` function to manually add a new axis with the correct characteristics. (See the help file for `?axis`, and notice that I've updated the $x$-axis title as well.)

```{r}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))),
     xlab = "GDP per capita",
     ylab = "Life expectancy at birth (years)",
     main = "1952",
     xaxt = "n")
axis(side = 1, at = 3:5, labels = 10^{3:5})
```

Great! Finally, let's add a legend. Here we might need two legends: one for the colours, and one for the point sizes. Let's add the colour legend first.

Since we're using filled points with borders and backgrounds, we use the `pt.bg` argument to set the background colours. We set the top-left corner of the legend to be at the point $(4.3, 70)$ (remember, points are plotted on the $\log_{10}$ scale, but the *axis labels* have been amended. So $x$-coordinates are in the approximate range $(2, 5)$, ***not*** $(`r 10^2`, `r 10^{5}`)$). Since they all have the same point character, we only need to set one value for `pch`, but we must set `r length(levels(gapminder$continent))` legend labels and `r length(levels(gapminder$continent))` colours.

```{r, echo = -c(1:2)}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))),
     xlab = "GDP per capita",
     ylab = "Life expectancy at birth (years)",
     main = "1952",
     xaxt = "n")
axis(side = 1, at = 3:5, labels = 10^{3:5})
legend(4.3, 70, legend = levels(gpm1952$continent), 
       pch = 21, 
       pt.bg = 1:length(levels(gpm1952$continent)),
       title = "Continent")
```

> **Notice**: the `legend()` function **adds** a legend to an existing plot. We only have to rerun the plotting commands if we make an error.

Finally, let's add a legend for the point scaling. Since this is a **continuous** variable, it's much more complex to plot. First we have to summarise the continuous scale at a set of discrete values. Let's choose 5 points, at the lower 2.5%, 25%, 50% (median), 75% and 97.5% quantiles of the range of (scaled) population sizes. The `quantile()` function in R helps us find out these values. We need to offset the legend slightly lower than the first legend, so let's try:

```{r, echo = -c(1:3)}
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))),
     xlab = "GDP per capita",
     ylab = "Life expectancy at birth (years)",
     main = "1952",
     xaxt = "n")
axis(side = 1, at = 3:5, labels = 10^{3:5})
legend(4.3, 70, legend = levels(gpm1952$continent), 
       pch = 21, 
       pt.bg = 1:length(levels(gpm1952$continent)),
       title = "Continent")
legend(4.3, 51, 
       legend = signif(quantile(gpm1952$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2), 
       pch = 21, 
       pt.cex = sqrt(200 * signif(quantile(gpm1952$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2) / (pi * max(gpm1952$pop))), 
       pt.bg = "black",
       title = "Population size")
```

Almost there! Let's format the population sizes slightly, and remove the boxes around the legends (`bty = "n"` sets **no** box type). The final plotting code is therefore:

```{r}
## produce plot of life expectancy against log10(GDP)
plot(log10(gpm1952$gdpPercap), gpm1952$lifeExp, 
     pch = 21, 
     bg = as.numeric(gpm1952$continent),
     cex = sqrt(200 * gpm1952$pop / (pi * max(gpm1952$pop))),
     xlab = "GDP per capita",
     ylab = "Life expectancy at birth (years)",
     main = "1952",
     xaxt = "n")

## manually re-label x-axis
axis(side = 1, at = 3:5, labels = 10^{3:5})

## add colour legend
legend(4.3, 70, legend = levels(gpm1952$continent), 
       pch = 21, 
       pt.bg = 1:length(levels(gpm1952$continent)),
       title = "Continent",
       bty = "n")

## add point size legend
legend(4.3, 51, 
       legend = signif(quantile(gpm1952$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2), 
       pch = 21, 
       pt.cex = sqrt(200 * signif(quantile(gpm1952$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2) / (pi * max(gpm1952$pop))), 
       pt.bg = "black",
       title = "Population size",
       bty = "n")
```

Wow, good job! The plot looks great, but this is just for one year. What if we want to repeat the plot for multiple years? Perhaps the easiest way to do this is to wrap the plotting code into a **function**, that takes a `data` argument, and a `year` argument, and then produces a plot accordingly.

```{r}
plotGapminder <- function(data, year = 1952)
{
    ## extract subset of data by year 
    data <- data[data$year == year, ]
    
    ## produce plot of life expectancy against log10(GDP)
    plot(log10(data$gdpPercap), data$lifeExp, 
         pch = 21, 
         bg = as.numeric(data$continent),
         cex = sqrt(200 * data$pop / (pi * max(data$pop))),
         xlab = "GDP per capita",
         ylab = "Life expectancy at birth (years)",
         main = year,
         xaxt = "n")
    
    ## manually re-label x-axis
    axis(side = 1, at = 3:5, labels = 10^{3:5})
    
    ## add colour legend
    legend(4.3, 70, legend = levels(data$continent), 
           pch = 21, 
           pt.bg = 1:length(levels(data$continent)),
           title = "Continent",
           bty = "n")
    
    ## add point size legend
    legend(4.3, 51, 
           legend = signif(quantile(data$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2), 
           pch = 21, 
           pt.cex = sqrt(200 * signif(quantile(data$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2) / (pi * max(data$pop))), 
           pt.bg = "black",
           title = "Population size",
           bty = "n")
}
```

This can now be called as follows (defaulting to plotting 1952 if not `year` argument used):

```{r}
plotGapminder(gapminder)
```

or even used in a loop to plot across multiple years:

```{r, fig.show = "hold"}
for(i in c(1952, 1962, 1972, 1982)) plotGapminder(gapminder, i)
```

> **Remember**: R creates **local** copies of arguments in functions. So in the function above, a local object `data` is created, which is a copy of the `gapminder` data. Hence the line `data <- data[data$year == year, ]` does not change the original `gapminder` object at all.

```{task}
Notice that this function is not very **robustly** written. The positions of the legends are fixed but the axes ranges change for different subsets of the data. Also, there are no checks-and-balances to ensure that the correct arguments are being input (for brevity we will not do this here, but it's good practice in general). I want you to:

1. Amend the function above to set the $x$- and $y$-axes to a **fixed** range (using the `xlim` and `ylim` plot arguments---see `?par`). These ranges can be obtained by extracting the $x$ and $y$ ranges from the data.
2. Set the legends so that they remain fixed regardless of what year is plotted. 
3. Fix the point size legend to use the same sizes regardless of the year. (Think about scaling the populations using **all** the data, generating point sizes for the legend and saving into a temporary object, ***before*** subsetting by year. This way the point sizes will be the same across all plots.)

Use this function to plot the years 1952, 1982, 1992 and 2002.
```

```{solution}

``{r, fig.width = 6, fig.height = 6}
plotGapminder <- function(data, year = 1952)
{
    ## produce point sizes 
    data$pop <- data$pop / max(data$pop)
    
    ## produce legend sizes
    leg_pop <- signif(quantile(data$pop, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)), 2)
    pt_pop <- sqrt(200 * leg_pop / pi)
    
    ## produce axes ranges
    ylims <- range(data$lifeExp)
    xlims <- range(log10(data$gdpPercap))
    ## extend bounds to fit legend in
    ylims[1] <- ylims[1] * 0.9
    xlims[2] <- xlims[2] * 1.1
    
    ## extract subset of data by year
    data <- data[data$year == year, ]
    
    ## produce plot
    plot(log10(data$gdpPercap), data$lifeExp, 
         pch = 21, 
         bg = as.numeric(data$continent),
         cex = sqrt(200 * data$pop),
         xlab = "GDP per capita",
         ylab = "Life expectancy at birth (years)",
         main = year,
         xaxt = "n",
         xlim = xlims,
         ylim = ylims)
    axis(side = 1, at = 3:5, labels = 10^{3:5})
    legend(4.7, 65, legend = levels(data$continent), 
           pch = 21, 
           pt.bg = 1:length(levels(data$continent)),
           title = "Continent",
           bty = "n")
    legend(4.7, 43, 
           legend = leg_pop, 
           pch = 21, 
           pt.cex = pt_pop, 
           pt.bg = "black",
           title = "Population size",
           bty = "n")
}
for(i in c(1952, 1982, 1992, 2002)) {
    plotGapminder(gapminder, i)
}
``

```

<!--chapter:end:ch_oldVis.Rmd-->

# Animations {#animation}

> **Important**: If you are doing this on your own machine, you will need to install a piece of software called [ImageMagick](https://www.imagemagick.org/script/index.php). The necessary binaries can be downloaded [here](https://www.imagemagick.org/script/download.php#windows); make sure you download the correct version for your operating system. If you are installing the Windows version, you must ensure that you tick the box labelled "Install legacy utilities (e.g. convert)" during the installation process---see Figure \@ref(fig:imagemagick).
>  
> ```{r, imagemagick, fig.cap = "Imagemagick installation screen"}
> include_graphics("images/imagemagick.png")
> ```
> Once installed, the rest of the code below should run accordingly. (I haven't checked this on a Mac, but on my Linux box I could install ImageMagick through the default package manager.)

> **Note**: The University machines have been installed without the legacy files, which means that the binary 'convert.exe' that is required to produce the animations is not available. One workaround is to set the global option 
> ```{r eval = F}
> ani.options(convert = 'C:/Program Files/ImageMagick-7.0.4-Q16/magick.exe')
> ```
> Once this is run then the animations should work. **Note also**: If running on your own machine you might need to replace the `C:/Program Files/ImageMagick-7.0.4-Q16/magick.exe` path with the correct path to the 'magick.exe' file on your own machine.

[Yihui Xie]((https://yihui.name/en/)) (of `knitr` fame) and colleagues have also produced the neat [`animation`](https://cran.r-project.org/web/packages/animation/) package, that enables animations to be produced from R. In essence we simply need to write a loop that produces different static plots, which can then be bound together by the `animation` package. Firstly, install the `animation` package if need be:

```{r, eval = F}
install.packages("animation")
```

Next, load the package:

```{r, cache = F}
library(animation)
```

Now produce an animated GIF as follows:

```{r, results = "hide", message = F}
saveGIF({
    ## function to produce multiple plots
    ## which get bound together as a GIF
    for(i in sort(unique(gapminder$year))){
        plotGapminder(gapminder, i)
    }
}, movie.name = "gapminder.gif", 
    ani.width = 500, ani.height = 500,
    interval = 0.5)
```

```{r, echo = F}
if (knitr:::is_latex_output()) {
    plotGapminder(gapminder, 1952)
} else {
    include_graphics("gapminder.gif")
}
```

> This function is slightly strange. The first argument is an R expression that generates multiple plots, which `saveGIF` then binds together. The other arguments relate to things like the size of the output file and how fast it skips between plots.

```{task}
Understand what the code inside the `saveGIF()` function is doing. Try making the animation slower.
```

```{solution}

``{r, eval = F}
## change the interval argument to slow animation down
saveGIF({
    ## function to produce multiple plots
    ## which get bound together as a GIF
    for(i in sort(unique(gapminder$year))){
        plotGapminder(gapminder, i)
    }
}, movie.name = "gapminderslow.gif", 
    ani.width = 500, ani.height = 500,
    interval = 1)
``

```

> **Note**: The `animation` package in R will also produce animations saved in other formats. For example, `saveHTML` will produce a HTML presentation, or `saveVideo` to save into .mp4 format. Sometimes these are preferable to GIF animations, because they can be interacted with (i.e. paused, stopped etc.). The `saveVideo` function requires an external package called [ffmpeg](https://ffmpeg.org/) to be installed. It works nicely enough on Linux, but I haven't tried it on Windows. I'm happy to try to help if any of you want to try this on your own machines, and run into any difficulties.

> **Update**: I *think* ffmpeg might be installed as part of ImageMagick. But don't quote me...

> **Inclusion in R Markdown**: these animations can also be included in R Markdown documents. The easiest way is to write a code chunk that saves into an external file, and then embed the file into the document. For example, the section above this with the R code to produce the GIF, followed by the animation was created with the following R Markdown code:
> ```{r, comment = NA, echo = F}
> cat("```{r, results = \"hide\", message = F}
> saveGIF({
>     ani.options(interval = 0.5, nmax = 50)
>     
>     for(i in sort(unique(gapminder$year))){
>         plotGapminder(gapminder, i)
>     }
> }, movie.name = \"gapminder.gif\", 
>       ani.width = 600, ani.height = 600)
> ``` \n
> ![](gapminder.gif)")
> ```
> Notice the options `results = "hide"` to make sure the chunk is run (in order to produce the GIF), but to *hide* any outputs, and the option `message = F` to suppress the output message that `saveGIF` automatically prints. This creates a file called "gapminder.gif" in the working directory, which we embed into the HTML output in the standard way for external figures, using the syntax `![](FILE)`---see the [R Markdown Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

> **Note**: this animation is not perfect, some points overlap the legends, and we'd be better off placing the legend in the outer margins of the plot and amending accordingly. The colours are also fairly garish, and perhaps using a more subtle palette would be better. R's base graphics system is **incredibly** flexible, but can often require a lot of work to generate complex plots. Next, we introduce a package written specifically for visualising data sets.

<!--chapter:end:ch_animations.Rmd-->

# Visualisation (the new-fangled way)

We have seen that the R base graphics system is highly flexible, and can be used to produce high-quality, bespoke animations and visualisations. However, it was a lot of work! Let's show an alternative way to produce a similar plot. We will introduce the code first, and then talk through it.

This uses the `ggplot2` package, so make sure it's loaded:

```{r}
library(ggplot2)
```

Now enter the following code:

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952") +
    guides(colour = guide_legend(title = "Continent")) +
    guides(size = guide_legend(title = "Population size")) +
    theme_bw()
```

Notice that we had to do little physical manipulation of the plot. We didn't have to choose how to position legends, or derive a function to scale point characters (`ggplot2` scales by **area** by default, and produces sensible relative sizes). The colours are muted and contrast well. It just worked really well straight-out-of-the-box. 

So, how does it work? `ggplot2` is based on a book called the [Grammar of Graphics](https://www.amazon.co.uk/Grammar-Graphics-Statistics-Computing/dp/0387245448) by [Leland Wilkinson](https://en.wikipedia.org/wiki/Leland_Wilkinson)---hence the name `gg`-`plot`! The ethos of `ggplot2` is that plots can be broken down into different **features**, most notably:

* data;
* aesthetic mapping;
* geometric object;
* statistical transformations;
* scales;
* coordinate system;
* position adjustments;
* faceting.

Perhaps the easiest way to explain some of these concepts is to work through our example step-by-step. Let's start with the first part of the code:

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent))
```

This sets up the plot. The first argument to the `ggplot` function is the **data**---here we have simply given it all the gapminder data from 1952.

> **Important**: whereas base R graphics can plot various object types, `ggplot()` **requires** `data.frame` (or `tbl`) objects. It is designed for plotting statistical data sets. Never fear, most R objects can be manipulated into `data.frames` for plotting if required. (See next practical on data wrangling.)

The `aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)` part sets the **aesthetics**, i.e. how the data are **mapped** onto the visual aesthetics of the plot (i.e. something you can visualise). Here we are setting the `x` coordinates to be `gdpPercap`, the `y` coordinates to be `lifeExp`, the `size` of the characters to be related to `pop`, and the `colour` of the characters to be related to `continent`. In general, **aesthetics** include:

* position;
* colour (border color);
* fill (inside color);
* shape;
* linetype;
* size.

> As usual, information can be found in the relevant help files, but a really useful resource for `ggplot2` is the [Data Visualisation Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf). Another fantastic resource, is the [R Graphics Cookbook](http://www.cookbook-r.com/Graphs/) by Winston Chang, which has a free online version, or a physical book that you can buy.

> **Notice** that we did not have to use the `$` operator to extract columns. This makes `ggplot2` code a bit clearer. R knows to look for the `gdpPercap` object in the `gapminder` data, because we have told `ggplot()` which data set to operate on.

Notice that only an **empty plot** has been drawn so far, there are no points present. This is because we haven't told `ggplot2` what type of plot we want. We do this by specifying a **geom**. 

> A **geom** defines the type of plot we want. In this case we want a **scatterplot**, which can be defined by the `geom_point()` function. Geoms can be layered, allowing us to built complex plots in different ways.

> **Note**: `ggplot2` **builds** plots up by *adding* together components. There are lots of ways to do this. Here I have set up "global" options for the plot (incuding the aesthetics) using the `ggplot()` function. I then **add** (`+`) to this the type of plot I want i.e. `+ geom_point()`. The addition sign is important. If I want to split the function over multiple lines, make sure the `+` sign is at the **end** of each line, so R knows that the plot is not complete at the point.

Let's see how this works:

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point()
```

Nice! With one tiny function we have added colours, point sizes *and* legends. All nicely formatted to work together in one plot.

> **Important**: Each type of `geom` accepts only a subset of all aesthetics. Information on these can be found in the help files for each `geom_*` type, or see also the [`ggplot2` Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf).

Next we want to plot GDP on the $\log_{10}$ scale. In base R we did this by transforming the variable itself. In `ggplot2` we can simply tell the `ggplot()` function to **scale** the $x$-axis accordingly. 

> **Scales** control how a plot maps data values to the visual values of an aesthetic. 

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10")
```

`ggplot2` has lots of built in transformations e.g. `"log"`, `"exp"`, `"sqrt"`, `"log10"` and so on. Or you can define your own. The `scale_x_continuous()` function tells `ggplot2` to plot the continuous `x` aesthetic (which is `gdpPercap` here) on the $\log_{10}$ scale. Notice that we have not transformed the data, we have merely told `ggplot()` on what scale to plot it. This also sorts out the axis labelling automatically. 

We can also scale other aesthetics. For example, although the relative areas of the points are scaled nicely, we probably want the largest points to be slightly larger. Hence we can scale the area of the maximum point by using the `scale_size_area()` function: 

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15)
```

Labels and titles can be added fairly easily, using the `xlab()`, `ylab()` and `ggtitle()` functions:

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952")
```

Changing the legend titles is a bit less intuitive unfortunately, but can be done using the `guides()` options (I had to Google this one). (Notice that the legends map to the aesthetics, so there is a `colour` legend that maps to the colour aesthetic, and a `size` legend that maps to the size aesthetic.)

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952") +
    guides(colour = guide_legend(title = "Continent")) +
    guides(size = guide_legend(title = "Population size")) 
```

Not bad. Finally notice that by default `ggplot2` uses a light-grey background. This seems to prove somewhat divisive. There is a solid theory behind choosing this as the default, since it provides clarity without having too much contrast. However, some people don't like it, and so there are options to turn this off (using `theme()`). In this case we can simply turn this off using `theme_bw()` (a black-and-white theme).

```{r}
ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952") +
    guides(colour = guide_legend(title = "Continent")) +
    guides(size = guide_legend(title = "Population size")) +
    theme_bw()
```

There are many, many possible options with `ggplot2`. Far too many to cover here. We can only really get a flavour of what can be achieved. I have often found [Google](www.google.com) to be invaluable for learning `ggplot2`. Let's have a look at a couple of other examples.

### GDP per continent

Another chart seen in Professor Rosling's talk was a stacked density plot. This is a smoothed version of a **histogram**. Let's start by looking at the distribution of GPD values across all countries in 1952. This can be done with the `geom_histogram()` geom, which requires only an `x` aesthetic---see`?geom_histogram`---since it calculates the counts on the $y$-axis automatically from the data once we have chosen an appropriate bandwidth.

```{r, message = F}
ggplot(gapminder[gapminder$year == 1952, ],
       aes(x = gdpPercap)) +
    geom_histogram()
```

This simple plot is producing a histogram of the distribution of GDP across **all countries** in 1952. How do split this by continent? Well, there are various ways. One way would be to set the `fill` aesthetic to map to the `continent` variable:

```{r}
ggplot(gapminder[gapminder$year == 1952, ],
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram()
```

This produces a **stacked histogram**, where each bar is coloured according to the relative frequency of each `continent`. This is more informative, we can see that African countries tend to have lower GDP per capita than the Americas for example. Asia and Africa were the poorest continents in the 1950s in terms of GDP. 

> **Important**: `ggplot2` also allows you to save the plot as an object, which can be updated at a later date or used within other functions. For example,
> ```{r}
p <- ggplot(gapminder[gapminder$year == 1952, ],
>        aes(x = gdpPercap, fill = continent)) +
>     geom_histogram()
> ```
> creates an object called `p` that contains the plot information. This will not be plotted until the objected is **printed** to the screen e.g.
> ```{r, message = F}
> p
> ```
> **Note**: If using `ggplot` inside functions you may have to explicitly use the `print()` function (e.g. `print(p)`).

```{task}
Try tidying up the axis and legend titles on these plots.
```

```{solution}

``{r}
ggplot(gapminder[gapminder$year == 1952, ],
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram() +
    xlab("GDP per capita") + 
    ylab("Count") +
    ggtitle("1952") +
    guides(fill = guide_legend(title = "Continent")) 
``
    
```

```{task}
Write a function in R that takes a `year` argument and plots histogram for a given year. Use this to plot the data for 1952, 1982, 1992 and 2002.
```

```{solution}

``{r}
plotGapminder_gg <- function(data, year = 1952) {
    p <- ggplot(gapminder[gapminder$year == year, ],
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram() +
    xlab("GDP per capita") + 
    ylab("Count") +
    ggtitle(year) +
    guides(fill = guide_legend(title = "Continent"))
    print(p)
}
for(i in c(1952, 1982, 1992, 2002)) {
    plotGapminder_gg(gapminder, i)
}
``

```

### Faceting

Another option would be to produce different histograms for each continent. This can be done in `ggplot2` by **faceting** e.g.

```{r, message = F}
ggplot(gapminder[gapminder$year == 1952, ],
       aes(x = gdpPercap)) +
    geom_histogram() +
    facet_wrap(~ continent)
```

Pretty neat eh? The `facet_wrap()` function allows R to choose how to position the subplots, there is also a `facet_grid()` function that allows you to set the plots out in a specifed grid format. This is more useful if you wish to facet by more than one variable. To this end, the  `~` operator allows for faceting by more than one variable. Please see the [Data Visualisation Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf) for more details. Notice also that it's fixed the axes to be the same across all plots. Useful eh? (These defaults can be relaxed of course, using the correct arguments.)

We can also map multiple aesthetics to variables, so we could facet by `continent` and colour by `continent`:

```{r, message = F}
ggplot(gapminder[gapminder$year == 1952, ],
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram() +
    facet_wrap(~ continent)
```

This plot is not really very informative, the colours add nothing more than the facets do. Perhaps a better plot would be to use a stacked histogram but facet by different years, to see how the relative distributions change over time:

```{r, message = F}
ggplot(gapminder,
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram() +
    facet_wrap(~ year)
```

Here the axis labels are difficult to read, due to the plot size, so perhaps we could rotate them. A quick Google search came up with [this](http://www.cookbook-r.com/Graphs/Axes_(ggplot2)/) page from the R Graphics Cookbook, so let's try:

```{r, message = F}
ggplot(gapminder,
       aes(x = gdpPercap, fill = continent)) +
    geom_histogram() +
    facet_wrap(~ year) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

```{task}
Revisit the "worms" examples from earlier practicals and produce the histograms, box plots and scatterplots using `ggplot2`. (You might have to manually adjust your binwidth to get reasonable looking histograms.)
```

```{solution}

``{r}
## read data into R
worms <- read.csv("worms.csv", header = T)

## plot histogram for worm density 
ggplot(worms, aes(x = Worm.density)) +
    geom_histogram(binwidth = 0.5) + 
    xlab("Worm Density")

# plot histogram for area
ggplot(worms, aes(x = Area)) +
    geom_histogram(binwidth = 0.25) + 
    xlab("Area")

## box-and-whisker plot for worm density against vegetation
ggplot(worms, aes(x = Vegetation, y =Worm.density)) +
    geom_boxplot() +
    ylab("Worm Density")

## scatter plot for worm density against area with
## fitted regression line
ggplot(worms, aes(y = Worm.density, x = Area)) +
    geom_point() +
    # Add linear regression line
    geom_smooth(method = lm, se = F) +
    ylab("Worm Density")
``

```

```{task}
Revisit the "fruitflies" examples from earlier practicals and reproduce something similar to the plot below using `ggplot2`
     
![Plot of fruitfly data stratified by experimental group](images/fruitflies.png).
```

```{solution}

``{r, fig.height = 4, fig.width = 8}
## load data
ff <- readRDS("ff.rds")

## amend factor labels for type to make
## easier to read
ff$type <- as.character(ff$type)
ff$type[ff$type == "0"] <- "Inseminated"
ff$type[ff$type == "1"] <- "Virgin"
ff$type[ff$type == "9"] <- "Control"
ff$type <- factor(ff$type)

ggplot(ff, aes(y = longevity, x = thorax, 
               colour = type)) +
    geom_point() +
    geom_smooth(method = lm, se = F) +
    facet_wrap(~ partners) +
    guides(colour = guide_legend(title = "Partner Type")) +
    ylab("Longevity (days)") +
    xlab("Thorax length (mm)")
``
    
```

> Another great `ggplot2` tutorial can be found [here](http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html).

<!--chapter:end:ch_newVis.Rmd-->

# Interactive visualisations

The advent of [Javascript](https://en.wikipedia.org/wiki/JavaScript) has enabled the development of powerful visualisation packages that enable graphics to be rendered in HTML and displayed using a web browser. On such Javascript library is called [plotly](https://plot.ly/), another is called [d3](https://d3js.org/). Naturally we do not want to learn another programming language here, but it is worth mentioning that one of the key features of R is its ability to incorporate other languages within its own. Here we will explore how the R package [`plotly`](https://cran.r-project.org/web/packages/plotly/index.html) enables us to draw interactive web graphics using R. 

> A great resource for `plotly` can be found at [https://plot.ly/r/](https://plot.ly/r/).

We will not spend very long on this here, but it's just to give you a flavour of what's possible.

> **Note**: if you want to include these sorts of graphics into documents produced by R Markdown, you will have to render into HTML only.

After installing the `plotly` package, we need to load it:

```{r, message = F}
library(plotly)
```

Let's think about the life expectancy graph vs. GDP we generated earlier using `ggplot2`. One key piece of information we left off was the names of the countries. One option we could use is to create an interactive HTML graph, where the name of the country appears once we hover over a point. Sounds complex right? Well actually not really! The `plotly` package for R provides a useful wrapper function `ggplotly()`, that takes a `ggplot2` object and automatically creates an interactive graphic using plotly. For example,

```{r}
p <- ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952") + 
    guides(colour = guide_legend(title = "Continent")) +
    guides(size = guide_legend(title = "Population size")) +
    theme_bw()

ggplotly(p)
```

```{task}
Have a play with the plot, notice that you can zoom in and pan around, take a screenshot, select points, interact with the legend and so on. Notice also, that if you hover over the points you get a **tooltip** giving lots of information about each point.
```

There are many options, which we will not go into here. One thing we will do is to change the tooltip to just display country. To do this we can specify which aesthetics we want to tooltip to display, using the `tooltip` argument to `ggplotly`. We have yet to set an aesthetic relating to country, and we actually do not want country to interfere with the plot in any way, other than as a tooltip. Hence we will set a "fake" aesthetic, called `extra`, when drawing the `ggplot` object. We then pass the name of this aesthetic to `ggplotly()`. 

```{r}
p <- ggplot(gapminder[gapminder$year == 1952, ], 
       aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent,
           extra = country)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    scale_size_area(max_size = 15) +
    xlab("GDP per capita") +
    ylab("Life expectancy at birth (years)") +
    ggtitle("1952") + 
    guides(colour = guide_legend(title = "Continent")) +
    guides(size = guide_legend(title = "Population size")) +
    theme_bw()

ggplotly(p, tooltip = "extra")
```
You can also use fairly syntaxes that are *similar* (though not identical) to R's native plot syntaxes, to produce simple interactive plots e.g.

```{r, message = F}
worms <- read.csv("worms.csv", header = T)
plot_ly(data = worms, x = ~Area, y = ~Worm.density)
```

All information on producing plotly plots in R can be found [here](https://plot.ly/r/) (be warned, the website can sometimes be slow to render). There is also a useful [plotly Cheat Sheet](https://images.plot.ly/plotly-documentation/images/r_cheat_sheet.pdf).

## Shiny

I will spend zero ($\pm$ a bit) on another key package in R: [Shiny](https://shiny.rstudio.com/). This is another great package from the developers at RStudio, which allows you to make interactive websites, powered by R. This is beyond what we will do in this module, but in case you're interested, there's a nice tutorial [here](https://shiny.rstudio.com/) and a gallery of examples [here](https://shiny.rstudio.com/gallery/). Have a look and be inspired!


<!--chapter:end:ch_interactive.Rmd-->

# Data Wrangling

It is estimated that data scientists spend around [50-80% of their time cleaning and manipulating data](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html?_r=0). This process, known as **data wrangling** (or **data munging**) is a key component of modern statistical science, particularly in the age of **big data**. We have already seen some examples of cleaning, manipulating and summarising data using some of R's core functions, here we introduce a set of tools that have been designed to work together to produce more fluid and readable code.

The team behind `ggplot2` have also put together various packages that provide functionality for doing common data wrangling tasks, such as transforming "wide" (or "messy") data into "long" (or "tidy") data, summarising, grouping, filtering and so on. Many if these operations can be achieved relatively straightforwardly using R's core functionality, however the code can often be non-trivial to decipher. The `tidyr` and `dplyr` packages we installed earlier, are an attempt to make common data wrangling tasks not only easier to achieve, but also easier to decipher. **Readability** of the code being a core ideal in the philosophy underpinning the packages. In the case of `dplyr`, several of the functions are substantially faster than the native R versions.

As usual with R, there are usually many ways to achieve the same outcome. These examples show how some common tasks can be achieved using `tidyr` and `dplyr`.

> Great resources are the [Data Import Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-import-cheatsheet.pdf) and [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-transformation-cheatsheet.pdf), which give lots of inofrmation about the `tidyr` and `dplyr` functions.

Let's pull up some data. You should have access to a .csv file called "indicator gapminder gdp_per_capita_ppp.csv" on ELE. This is a digital download of the [Gapminder](https://www.gapminder.org/) GDP per capita data that can be found in the `gapminder` package. All the data sets used in the [Gapminder](https://www.gapminder.org/) project can be downloaded from [https://www.gapminder.org/data/](https://www.gapminder.org/data/).

Download this file and save it into your working directory. To start with, we will load the data into R and go through the steps to clean it up individually. Afterwards, we will use some neat features of `tidyr` and `dplyr` to do this much more succinctly.

Firstly, let's load the packages we need:

```{r, message = F}
library(tidyr)
library(dplyr)
library(tibble)
library(ggplot2)
```

First, read in the data and convert it into a `tbl` object for ease of visualisation:

```{r}
gp_income <- read.csv("indicator gapminder gdp_per_capita_ppp.csv", header= T)
gp_income <- as_tibble(gp_income)
gp_income
```

We can see that this is in "wide" format. The first column contains the country names, and the other columns correspond to each year. The first column is labelled incorrectly as `GDP.per.capita` (this is an artefact from the original data set), so let's rename the first column using the `rename()` function:

```{r}
gp_income <- rename(gp_income, country = GDP.per.capita)
gp_income
```

Notice that the `rename()` function takes a `data.frame` / `tbl` object as its first argument, amends the column names and then passes a `data.frame` / `tbl` object out as its return value. We then overwrite the original data frame to keep our workspace neat.

> **Note**: this is OK here because we have a copy of our **raw** data saved in an external file. This, combined with the use of **scripts**, means we have a backup of the original data in case anything goes wrong. Don't overwrite your original data set!

The next thing we need to do is to collapse the **year** columns down. Ideally we want a column corresponding to **country**, a column corresponding to **year** and a final column corresponding to **GDP**. We saw in a previous practical that we can do this using the `gather()` function in `tidyr`. In the earlier example we collapsed **all** columns down. Here we wish to only collapse those corresponding to **years**. We can do this by adding some additional arguments to `gather()`: 

* `key` gives the name of the column that will contain the collapsed column names (e.g. `X1800`, `X1801` etc.);
* `value` gives the name of the columns that will contain the **values** in each of the cells of the collapsed column (e.g. the corresponding GDP values);
* the final set of arguments correspond to those columns we wish to collapse. Here we want to collapse everything ***except*** `country`, which we can do using the `-` operator.

> **Note**: `tidyr` and `dplyr` functions tend to always take a `data.frame` object as their first argument, therefore the authors have written the functions such that we do not need to use quotes `""` around column names (e.g. `"year"`, `"country"` etc.)

```{r}
gp_income <- gather(gp_income, key = year, value = gdp, -country)
gp_income
```

Great! This is what we're looking for! Notice that R has left the new `year` column as a `character` vector. R will not take numbers as column names, and so R prepends the years with an `X`; so `"1800"` becomes `"X1800`" and so on. Fortunately we are able to remove this extraneous `X` using a function in R called `gsub()`, which simply searches for a given pattern within each element of a character vector, and replaces it with something else. Hence the command `gsub("X", "", gp_income$year)` would search for the pattern `"X"` in each element of the vector `gp_income$year`, and replace it with an empty string `""`. Once the `"X"` is removed we can turn the `character` vector into a `numeric` vector:

```{r}
gp_income$year <- gsub("X", "", gp_income$year)
gp_income$year <- as.numeric(gp_income$year)
gp_income
```

> **Note** that `dplyr` provides a `mutate()` function that will do this also, and in fact we will use this later on: `gp_income <- mutate(gp_income, year = as.numeric(gsub("X", "", year)))`. Please see the [Data Wrangling Cheat Sheets](https://www.rstudio.com/resources/cheatsheets/) for more information.

This is almost there now, there is quite a lot of extraneous information in the data. Firstly, there were some mostly empty rows in Excel, which manifest as a country called `""` when the data were read into R (see the first element below---I am only printing the first few entries for brevity):

```{r}
head(levels(gp_income$country))
```

We can examine these rows by subsetting. A command `gp_income[gp_income$country == "", ]` would extract these rows, but I will use a `dplyr` function called `filter()` to do the same thing (it will become clearer why later on).

```{r}
summary(filter(gp_income, country == ""))
```

We can see from the summary that only one row has any GDP information, and indeed in the original data there was a single additional point that could be found in cell HE263 of the original Excel file. I think this is an artefact of the original data, and as such we will remove it here:

```{r}
gp_income <- filter(gp_income, country != "")
```

We can also remove the rows that have no GDP information if we so wish (which are denoted by **missing values**---`NA`):

```{r}
gp_income <- filter(gp_income, !is.na(gdp))
```

Finally, we will restrict ourselves to looking at the data from 1990 onwards:

```{r}
gp_income <- filter(gp_income, year > 1990)
summary(gp_income)
```

One final thing to note is that when we removed the `country` values above, the `levels` of the `factor` remained the same. R simply says there are no entries with the level `""`. A useful function called `droplevels()` will go through each `factor` column in a `data.frame` and reset the levels accordingly.

```{r}
gp_income <- droplevels(gp_income)
summary(gp_income)
```

Phew! this took some effort, but we've managed to end up with a fairly clean data set that we can plot, summarise etc. Before we do that, I'm going to introduce you to a feature of `tidyr` and `dplyr` that can make our code much more **succinct**.

### Pipes (`%>%`)

You will notice that I chose to use functions such as `filter()` and `mutate()` above, when I could have just extracted the correct column of the data, done the appropriate manipulation, and then overwrote the column. Why then, did I choose to use these functions?

The key aspect that these functions share is that they take a `data.frame` as their first argument, and return a `data.frame`. Whilst this may not seem useful, this means that we can use **pipes** to make our code more succinct.

> **Aside**: piping comes from Unix scripting, and simply means a chain of commands, such that the results from each command feed into the next one. 

Recently, `tidyr` and `dplyr` have introduced the pipe operator `%>%` that enables us to chain functions together. Let's look at an example:

```{r}
gp_income %>% filter(year == 1991)
```

> **Notice**: when we did this before we would write something like `filter(gp_income, year == 1991)` i.e. we required the first argument of `filter()` to be a `data.frame` (or `tbl`). The pipe operator `%>%` does this automatically, so the outcome from the left-hand side of the operator, is passed as the ***first*** argument to the right-hand side function. This makes the code more succinct, and easier to read (because we are not repeating pieces of code).

Pipes can be chained together multiple times e.g. 

```{r}
gp_income %>% filter(year == 1991) %>% summary
```

Notice that if a function ***only*** requires one argument (such as `summary()`), then I do not even need the brackets on the end. To do our previous data cleaning using pipes, we can write:

```{r}
gp_income <- read.csv("indicator gapminder gdp_per_capita_ppp.csv", header= T)

gp_income <- gp_income %>%
                as_tibble %>% 
                gather(year, gdp, -GDP.per.capita) %>%
                mutate(year = as.numeric(gsub("X", "", year))) %>%
                rename(country = GDP.per.capita) %>%
                filter(country != "") %>%
                filter(!is.na(gdp)) %>%
                filter(year > 1990) %>%
                droplevels
```

I think this is neat! The code is written in a way that is much easier to understand, each part of the data wrangling process is chained together in an intuitive way (once you know the `tidyr` and `dplyr` functions of course). Try doing the same level of data cleaning in Excel as easily...

> **Note**: in the code above we pass the result of the right-hand side out and overwrite the object `gp_income` using the assignment operator `<-` as we have previously done. The pipes have to be at the end of each line if you want to break the code across multiple lines, else R will think the pipeline has ended before it has.

Once we've got our head around pipes, we can begin to use some of the other useful functions in `dplyr` to produce summaries, for example, we might want to produce a mean GDP for each country, averaging over years. In this case we can think of "grouping" the data by country and then averaging the GDP values within each group. Hence,

```{r}
gp_income %>% 
    group_by(country) %>%
    summarise(mean(gdp))
```

The `summarise()` function (note, this is different to the `summary()` function), applies a function to a `data.frame` or subsets of a `data.frame`. Think of it a bit like the `tapply` function we saw in the first practical. Here we grouped the data frame according to country, and then ask for a `mean()` average of the `gdp` values (which here corresponds to averaging across the years).

We could do the same across the years:

```{r}
gp_income %>% 
    group_by(year) %>%
    summarise(mean(gdp))
```

We must be a bit careful here, since we may have less samples for some countries/years than for others. This affects the uncertainty in our estimates, though it is not too difficult to extract standard errors for each grouping and thus produce confidence intervals to quantify which estimates are more uncertain than others (which we will do in the Statistical Modelling modules in future years).

Please take a look at the [Data Wrangling Cheat Sheets](https://www.rstudio.com/resources/cheatsheets/).

```{task}
Load in the file "indicator hiv estimated prevalence% 15-49.csv" that can be found on ELE. This file contains the estimated HIV **prevalence** in people of age 15--49 in different countries over time. **Prevalence** is defined here to be the estimated number of people living with HIV per 100 population. Produce a **tidy** data set called `gp_hiv` using the tools in `tidyr` and `dplyr` that we introduced above. The dataset needs to run from 1991 onwards, and we want to end up with columns `country`, `year` and `prevalence`.
```

```{solution}

``{r, echo = -3}
gp_hiv <- read.csv("indicator hiv estimated prevalence% 15-49.csv", header= T)
gp_hiv <- gp_hiv %>%
                tbl_df %>% 
                gather(year, prevalence, -Estimated.HIV.Prevalence.....Ages.15.49.) %>%
                mutate(year = as.numeric(gsub("X", "", year))) %>%
                rename(country = Estimated.HIV.Prevalence.....Ages.15.49.) %>%
                filter(country != "") %>%
                filter(!is.na(prevalence)) %>%
                filter(year > 1990) %>%
                droplevels
saveRDS(gp_hiv, "gp_hiv.rds")
``

```

### Joins

We now have two data sets: `gp_income` and `gp_hiv`. In order to visualise and analyse them, we need to link them together. A key skill to have in data manipulation is the ability to **join** data sets (or tables) together. The `dplyr` package provides various functions to do this, depending on ***how*** you want to join the tables.

> In case you haven't managed to complete the last task, the `gp_hiv` data is available on ELE as "gp_hiv.rds". You can read this into R and continue with the practical.

In order to join two tables, you must have one or more variables **in common**. In this case we want to match by `country` and `year`, to produce a data set that contains `country`, `year`, `gdp` and `prevalence`.

There should be *at most* one entry for each `country` $\times$ `year` combination. We can check this using the `count()` function in `dplyr`:

```{r}
count(gp_income, country, year) %>% summary
count(gp_hiv, country, year) %>% summary
```

> `count()` counts the numbers of entries in each combination of the provided variables: in this case `year` and `country`. The `summary()` function is to provide a straightforward way to see that all the `country` $\times$ `year` combinations have one entry only.

This should make it straightforward to join. Hence,

```{r}
gp <- inner_join(gp_income, gp_hiv, by = c("year", "country"))
gp
```

Notice, this gave us a warning:

```
Warning in inner_join_impl(x, y, by$x, by$y, suffix$x, suffix$y): joining
factors with different levels, coercing to character vector
```

This means that there were some countries that were present in one data set but **not** the other (hence the `factor`s had different `levels`). R sorted this out by converting the `country` variable to a `character` (thus stripping away the level information). To have a look at where they differ, we can use either `semi_join()` or `anti_join()` (please see [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-transformation-cheatsheet.pdf)). The function `anti_join(gp_income, gp_hiv, by = c("year", "country"))` will return all rows of `gp_income` that can't be matched to `gp_hiv`:

```{r}
anti_join(gp_income, gp_hiv, by = c("year", "country"))
anti_join(gp_hiv, gp_income, by = c("year", "country"))
```

We can see that there are `r nrow(anti_join(gp_income, gp_hiv, by = c("year", "country")))` entries present in `gp_income` that can't be matched to `gp_hiv`, but `r nrow(anti_join(gp_hiv, gp_income, by = c("year", "country")))` entries in `gp_hiv` that can't be matched to `gp_income`. 

### Types of join

> **Inner joins** return ***only*** those rows that can be matched in both data sets, it discards any rows from either data frame that can't be matched.

> **Outer joins** retain rows that don't match, depending on the type of join. **Left** outer joins retain rows from the left-hand side that don't match the right, but discard rows from the right that don't match the left. **Right** outer joins retain rows from the right-hand side that don't match the left, but discard rows from the left that don't match the right. **Full** outer joins return all rows that don't match. R uses missing values (`NA`) to fill in gaps that it can't match. For example,
> ```{r}
> left_join(gp_income, gp_hiv, by = c("year", "country"))
> ```
> Here we can see that there is no prevalence data for `Afghanistan` in `1991`, so R has included the row but with a missing value (`NA`) in place of the prevalence data. In the `inner_join` above, this row was removed. Try exploring **right-** and **full-** outer joins.
> ```{r}
> right_join(gp_income, gp_hiv, by = c("year", "country"))
> full_join(gp_income, gp_hiv, by = c("year", "country"))
> ```
> What do you notice about the **left-** and **full-** outer joins here? Why is this so?

We want to plot HIV prevalence against GDP per capita, and so an **inner join** is sufficient here.

> There is a great cheat sheet for joining that I found [here](http://stat545.com/bit001_dplyr-cheatsheet.html).

Hopefully we have now cleaned two data sets, merged them together and can now proceed with visualising them.

```{task}
Using `ggplot2`, produce a plot of HIV prevalence in 15-49 year olds against $\log_{10}$ (GDP per capita) for 1991, 1997, 2005 and 2011, where each point represents a `country`.
```

```{solution}

``{r}
## here is one solution using filtering, piping and faceting
gp %>%
    filter(year == 1991 | year == 1997 | year == 2005 | year == 2011) %>%
    mutate(year = factor(year)) %>%
    ggplot(aes(x = gdp, y = prevalence)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    xlab("GDP per capita") +
    ylab("HIV prevalence in 15-49 year olds") +
    facet_wrap(~year)
``

```

```{task}
Total population data are available in the "indicator gapminder population.csv" document on ELE. Load this into R, tidy it up, and then join it to the `gp` data you have already created.
```

```{solution}

``{r}
## read in data
gp_pop <- read.csv("indicator gapminder population.csv", header= T)

## tidy data
gp_pop <- gp_pop %>%
                tbl_df %>% 
                gather(year, pop, -Total.population) %>%
                mutate(year = as.numeric(gsub("X", "", year))) %>%
                rename(country = Total.population) %>%
                filter(country != "") %>%
                filter(!is.na(pop)) %>%
                filter(year > 1990) %>%
                droplevels

## check no population data are missing
## hence all rows of gp can be matched
anti_join(gp, gp_pop, by = c("year", "country"))

## join to gp table
gp <- inner_join(gp, gp_pop, by = c("year", "country"))
``

```

```{task}
Produce a new plot of HIV prevalence against GDP per capita for 1991, 1997, 2005 and 2011, where each point represents a `country` and where the point sizes are scaled by population size.
```

```{solution}

``{r}
## here is one solution using filtering, piping and faceting
gp %>%
    filter(year == 1991 | year == 1997 | year == 2005 | year == 2011) %>%
    mutate(year = factor(year)) %>%
    ggplot(aes(x = gdp, y = prevalence, size = pop)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    guides(size = guide_legend(title = "Population size")) +
    xlab("GDP per capita") +
    ylab("HIV prevalence in 15-49 year olds") +
    facet_wrap(~year)
``

```

# Example---Population pyramids

[Population pyramids](https://en.wikipedia.org/wiki/Population_pyramid) are commonly used by demographers to illustrate age and sex structure of a country's population. A schematic example of a population pyramid is shown in Figure \@ref(fig:poppyramid).

```{r, poppyramid, fig.cap = "Schematic diagram of a population pyramid (source: Wikipedia)"}
include_graphics("images/Population_pyramid_example.svg")
```

Here we look at the population counts for three countries: Germany, Mexico and the US from the year 2000. On ELE you will find three files: "Germanypop.csv", "Mexicopop.csv" and "USpop.csv", each with the following columns:

* **male**: Population counts for males ($\times$ 1000);
* **female**: Population counts for females ($\times$ 1000).

Each row corresponds to an age class, in the order: 0--4, 5--9, 10--14, 15--19, 20--24, 25--29, 30--34, 35--39, 40--44, 45--49, 50--54, 55--59, 60--64, 65--69, 70--74 and 75--79. Mexico then has a final age class of 80+; Germany has final age classes of 80--84 and 85+; and the US has final age classes of 80--84, 85--89, 90--94 and 90+.

Original source: [US Census](http://www.census.gov/)

(I downloaded these data sets from the very excellent QELP website: [http://www.seattlecentral.edu/qelp/sets/032/032.html](http://www.seattlecentral.edu/qelp/sets/032/032.html), and wish to thank the authors for providing a brilliant resource for teaching statistics.)

In this exercise we will load these data into R, wrangle them into a useful format and then produce a population pyramid using `ggplot2`. We will aim to do all of this using a `tidyr`/`dplyr`/`ggplot2` workflow where possible.

## Data Wrangling

Firstly, we read the three data files into R, storing them as `tbl` objects called `germany`, `mexico` and `us`, making sure the data frames have informative column names. 

```{r}
## read German data in
germany <- read.csv("Germanypop.csv", header = F)
## set column names
colnames(germany) <- c("male", "female")

## read Mexican data in
mexico <- read.csv("Mexicopop.csv", header = F)
## set column names
colnames(mexico) <- c("male", "female")

## read US data in
us <- read.csv("USpop.csv", header = F)
## set column names
colnames(us) <- c("male", "female")

## produce summaries
summary(germany)
summary(mexico)
summary(us)
```

Next we add some information on the age classes. Taking Mexico as an example, we need to create a `character` vector containing the age classes, in the format shown i.e. `"0-4"` etc. finishing with `80+`. Rather than type out the age classes long-hand, we will start with a `numeric` vector: `age <- seq(0, 80, 5)`, and use various functions and operators we've already seen to expand this to the format we want:

```{r}
## set vector of inputs
age <- seq(0, 80, 5)

## create character vector of age classes
age <- c(
    apply(cbind(age[-length(age)], age[-1] - 1), 1, paste, collapse = "-"),
    paste0(age[length(age)], "+"))

## append age classes
mexico <- mutate(mexico, age = factor(age, levels = age))

## tidy up
rm(age)
```

```{task}
Go through the code chunk above and make sure you understand what each component is doing. Try copying-and-pasting discrete parts of the code to see how these nested functions build up.
```

```{task}
Generate age classes for the German and US datasets, and append an `age` column in a similar way.
```

```{solution}

``{r}
## append age classes to german data
age <- seq(0, 85, 5)
age <- c(
    apply(cbind(age[-length(age)], age[-1] - 1), 1, paste, collapse = "-"),
    paste0(age[length(age)], "+"))
germany <- mutate(germany, age = factor(age, levels = age))

## append age classes to german data
age <- seq(0, 95, 5)
age <- c(
    apply(cbind(age[-length(age)], age[-1] - 1), 1, paste, collapse = "-"),
    paste0(age[length(age)], "+"))
us <- mutate(us, age = factor(age, levels = age))
``

```

This looks good so far; summaries of the three data sets can be seen below:

```{r}
summary(germany)
summary(mexico)
summary(us)
```

One issue is that these three data sets have different age classes. One way to deal with this is to recategorise the US and German data such that the top age class is `80+`. For Germany, this means we have to sum the entries in the `80-84` and `85+` classes, and for the US it means we have to sum the `80-84`, `85-89`, `90-94` and `95+` classes. For the German data we can do something like:

```{r}
germany <- germany %>%
    mutate(age = as.character(age)) %>% ## converts factor to character
    mutate(age = ifelse(age == "85+" | age == "80-84", "80+", age)) %>% ## replaces age categories
    group_by(age) %>% ## groups by age
    summarise(male = sum(male), female = sum(female)) %>% ## sums together counts in additional age groups
    mutate(age = factor(age, levels = levels(mexico$age))) ## converts character back to factor (with correct levels)
```

This first strips the levels information out by converting the `age` column to a `character`. Then we use the `ifelse()` function to search-and-replace the relevant strings. Then we sum together the counts according to different levels of `age` (since we now have multiple entries for the `80+` age class). Finally we convert `age` back to a `factor`, being careful to set the order of the levels to be the same as the `mexico` data (remember R converts using lexicographical ordering otherwise). 

```{task}
Run through a similar workflow to recategorise the US age classes.
```

```{solution}

``{r}
us <- us %>%
    mutate(age = as.character(age)) %>% ## converts factor to character
    mutate(age = ifelse(age == "95+" | age == "90-94" | 
                            age == "85-89" | age == "80-84", "80+", age)) %>% ## replaces age categories
    group_by(age) %>% ## groups by age
    summarise(male = sum(male), female = sum(female)) %>% ## sums together counts in additional age groups
    mutate(age = factor(age, levels = levels(mexico$age))) ## converts character back to factor (with correct levels)
``

```

> **Note**: a slightly less verbose option would be to use the `revalue()` or `mapvalues()` functions in the [`plyr`](https://cran.r-project.org/web/packages/plyr/) package, see [here](http://www.cookbook-r.com/Manipulating_data/Recoding_data/) for some examples.

Now we will join together the three tables to create one larger data set. We will first join the three data sets together on the `age` column, before gathering together the `male` and `female` counts for each country into two columns, one of population counts (`pop`) and one relating to `sex` (which actually captures `sex` and `country` at this stage). We then separate the `sex` and `country` values into two separate columns, before setting them to be `factor` types. We do this using a single piped workflow that avoids us having to create lots of temporary objects:

```{r}
pop <- germany %>%
        inner_join(mexico, "age", suffix = c("_Germany", "_Mexico")) %>%
        inner_join(us, "age") %>%
        rename(male_US = male, female_US = female) %>%
        gather("country", "pop", -age) %>%
        separate(country, c("sex", "country"), sep = "_") %>%
        mutate(country = factor(country), sex = factor(sex))
pop
summary(pop)
```

```{task}
Go through the workflow above and understand what each line is doing and why. Add comments to the code. If you don't understand, please ask one of the demonstrators.
```

## Visualisation

Finally, we have wrangled our data into a useful form for data analysis. Now we will try and plot some population pyramids using `ggplot2`.

```{r}
ggplot(pop, aes(x = age, y = ifelse(sex == "male", -pop, pop), fill = sex)) + 
    geom_bar(stat = "identity") +
    scale_y_continuous(breaks = signif(seq(-max(pop$pop), max(pop$pop), length.out = 5), 2), 
                     labels = abs(signif(seq(-max(pop$pop), max(pop$pop), length.out = 5), 2))) +
    coord_flip() +
    facet_wrap(~ country, ncol = 1) +
    ylab("Population counts (x1000)") +
    xlab("Age (yrs)") +
    guides(fill = guide_legend(title = "Sex"))
```

Beautiful isn't it? (The horrendously stereotypical gender colours are purely a coincidence due to the defaults in `ggplot2`, please feel free to change them to something less egregious.) These plots are hugely informative. We know that countries experiencing fast population growth typically have a large number of individuals of reproductive age, with a wider base to the pyramid. In contrast, populations that have slow, static or even negative growth typically have more older individuals; their pyramids tend to be wider at the top. 

In the year 2000, the population distribution of Mexico shows a very bottom-heavy pattern, suggesting few older people, but a large number of young and middle-age people. In fact we can quantify this directly as:

```{r}
pop %>%
    group_by(country, age) %>%
    summarise(pop = sum(pop)) %>%
    arrange(country, age) %>%
    group_by(country) %>%
    mutate(cumprop = cumsum(pop / sum(pop))) %>%
    select(-pop) %>%
    spread(age, cumprop)
```

```{task}
Go through the workflow above and understand what each line is doing and why. Add comments to the code. If you don't understand, please ask one of the demonstrators.
```

We can see here that around 55% of Mexicans are younger than 25, compared to around 27% of Germans and 35% of Americans. We can also look at these figures split by sex:

```{r}
pop %>%
    arrange(country, sex, age) %>%
    group_by(country, sex) %>%
    mutate(cumprop = cumsum(pop / sum(pop))) %>%
    select(-pop) %>%
    spread(age, cumprop)
```

Mexico also has a very high proportion of young females: in fact 33% of the current population of women are of pre-reproductive age (0--14 years) and 49% are of reproductive age (15--44). This means Mexico's population is expected to rapidly increase in the near future. A general pattern is that as countries transition from more agricultural economies to more industrialised economies, birth rates drop (due to better access to family planning, increased job opportunities for women, and various other factors). As soon as birth rates approach death rates then population growth declines, and the population pyramid becomee more top-heavy. The US is currently classed as a medium-growth country, and Germany a negative-growth country. The population pyramid plot also helps visualise the overall differences in population sizes between the three countries.

A good description of population demographics can be found in this short video:

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/QsBT5EQt348" frameborder="0" allowfullscreen></iframe></center>

Another great site on these sorts of topics is the [OurWorldInData](https://ourworldindata.org/) project.

<!--chapter:end:ch_dataWrangling.Rmd-->

# Answers

```{r, echo = F, results = "asis"}
for(i in 1:length(solLabels)) {
    if(!is.na(solLabels[[i]][2][1])) {
        taskCtr <- solLabels[[i]][1]
        refLabel <- solLabels[[i]][2]
        cat(paste0("\\hypertarget{sol", taskCtr, "}{}\n\\bblockS{", taskCtr, "}\n"))
        cat(refLabel)
        cat(paste0("\n\n\\vspace{\\baselineskip}\\hyperlink{tsk", taskCtr, "}{\\buttonT{Return to task}}"))
        cat("\n\\eblockS\n")
    }
}
```


<!--chapter:end:ch_appendix.Rmd-->

