# Data Wrangling

It is estimated that data scientists spend around [50-80% of their time cleaning and manipulating data](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html?_r=0). This process, known as **data wrangling** is a key component of modern statistical science, particularly in the age of **big data**. You should already be familiar with cleaning, manipulating and summarising data using some of R's core functions. The `tidyverse` incorporates a suite of packages, such as `tidyr` and `dplyr` that are designed to make common data wrangling tasks not only easier to achieve, but also easier to decipher. **Readability** of the code being a core ideal in the philosophy underpinning the packages. 

> Great resources are the [Data Import Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf) and [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf), which give lots of information about functions available in different `tidyverse` packages[^3].

[^3]: Note that we do not make distinctions between which functions belong to which `tidyverse` packages here. Most of the functions we will use belong to either `readr`, `dplyr`, `tidyr` or `ggplot2`. Information on these packages can be found on the cheat sheets.

Before we go any further, if you haven't already, please load `tidyverse`:

```{r, message = F}
library(tidyverse)
```

## Tidy data

The architect behind the `tidyverse`, [Hadley Wickham](http://hadley.nz/), distinguishes between two types of data set: **tidy** and **messy**. This is not to be pejorative towards different ways in which people store and visualise data; rather it is to make a distinction between a specific way of arranging data that is useful to most R analyses, and anything else. In fact Hadley has a neat analogy to a famous Tolstoy quote:

> "Tidy datasets are all alike but every messy dataset is messy in its own way."---Hadley Wickham

Specifically, a **tidy** data set is one in which:

* rows contain different **observations**;
* columns contain different **variables**;
* cells contain values.

The idea of 'tidy' data gives rise to the nomenclature of the `tidyverse`. In this workshop we will see various ways in which datasets can be manipulated to and from the 'tidy' format.

## Simple manipulations

Let's look at a simple example. The `iris` data set we saw in the last session.

```{r}
head(iris)
```

```{task}
Is this data set 'tidy'?
```

```{solution}
Yes, this data set is tidy. Each row corresponds to an individual observation, each column to a variable and each cell to a specific value.
```

Let's start by looking at some basic operations, such as subsetting, sorting and adding new columns. We will compare the `tidyverse` notation with base R.

### Filter rows

One operation we often want to do is to extract a subset of rows according to some criterion. For example, we may want to extract all rows of the `iris` dataset that correspond to the `versicolor` species. In base R we can do this as:

```{r, eval = F}
iris[iris$Species == "versicolor", ]
```

```{r, echo = F}
head(iris[iris$Species == "versicolor", ])
```

In `tidyverse`, we can use a function called `filter()`:

```{r, eval = F}
filter(iris, Species == "versicolor")
```

```{r, echo = F}
head(filter(iris, Species == "versicolor"))
```

Notice some minor differences. The first argument to the `filter()` function is the data, and the second corresponds to the criteria for filtering. Notice that we did not need to use the `$` operator in the `filter()` function, as with `ggplot2` the `filter()` function knows to look for the column `Species` in the data set `iris`.

### Sort rows

Another common operation is to sort rows according to some criterion. Let's say we want to sort rows by `Species` and then `Sepal.Length`. In base R we could do this as:

```{r, eval = F}
iris[order(iris$Species, iris$Sepal.Length), ]
```

```{r, echo = F}
head(iris[order(iris$Species, iris$Sepal.Length), ])
```
In `tidyverse` we can use the `arrange()` function.

```{r, eval = F}
arrange(iris, Species, Sepal.Length)
```

```{r, echo = F}
head(arrange(iris, Species, Sepal.Length))
```

Notice once again that the first argument to `arrange()` is the data set, and then subsequent arguments are the columns that we wish to order by. Again, we do not require the `$` operator here.

### Select columns

Now let's say that we wish to select just the `Species`, `Sepal.Length` and `Sepal.Width` columns from the data set. There are various ways that we could do this in base R. Here are a few options:

```{r, eval = F}
## option 1
iris[, match(c("Species", "Sepal.Length", "Sepal.Width"), colnames(iris))]

## option 2
cbind(Species = iris$Species, Sepal.Length = iris$Sepal.Length, Sepal.Width = iris$Sepal.Width)

## option 3 (requires knowing which columns are which)
iris[, c(5, 1, 2)]
```

In `tidyverse` we can use the `select()` function:

```{r, eval = F}
select(iris, Species, Sepal.Length, Sepal.Width)
```

```{r, echo = F}
head(select(iris, Species, Sepal.Length, Sepal.Width))
```

Notice once again that the first argument to `select()` is the data set, and then subsequent arguments are the columns that we wish to select; no `$` operators required. There is even a set of functions to help extract columns based on pattern matching e.g.

```{r, eval = F}
select(iris, Species, starts_with("Sepal"))
```

See the [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf) for more examples.

Note that we can also remove columns using a `-` operator e.g.

```{r, eval = F}
select(iris, -starts_with("Petal"))
```

or 

```{r, eval = F}
select(iris, -Petal.Length, -Petal.Width)
```

would remove the petal columns.

### Adding columns

Finally, let's add a new column called `Sepal.Length2` that contains the square of the sepal length. In base R:

```{r, eval = F}
iris$Sepal.Length2 <- iris$Sepal.Length^2
```

In `tidyverse`:

```{r, eval = F}
mutate(iris, Sepal.Length2 = Sepal.Length^2)
```

```{r, echo = F}
head(mutate(iris, Sepal.Length2 = Sepal.Length^2))
```

Once again (you should notice a theme here) the first argument to `mutate()` is the data set, and then the new column as a function of the original column; no `$` operators required.

### Why bother?

So, why would I choose to use functions such as `filter()` and `mutate()` above, when I could have just extracted the correct column of the data, done the appropriate manipulation, and then overwrote or added a new column. There are various reasons:

1. These functions are all written in a **consistent** way. That is, they all take a `data.frame` or `tibble` object as their initial argument, and they all return a revised `data.frame` or `tibble` object. 
2. Their names are informative. In fact they are **verbs**, corresponding to us **doing something specific** to our data. This makes the code much more readable, as we will see subsequently.
3. They do not require lots of extraneous operators: such as `$` operators to extract columns, or quotations around column names.
4. Functions adhering to these criteria can be developed and expanded to perform all sorts of other operations, such as summarising data over groups.

> **Note**: Some R users like to use a function called `attach`. For example, `attach(iris)` would load the names of the variables in the `iris` data frame into the search path in R. This means that you don't have to use the `$` command to extract a column. The advantage of this is that the code can often be made clearer e.g. 
> ```
> attach(iris)
> Sepal.Length2 <- Sepal.Length^2
> ```
> The variable names can be removed from the search path by using `detach(iris)`. However, it is very easy to make errors when using this method, particularly if one wishes to change elements of the underlying data frame. As such I would recommend **never** using `attach()`. For example, the code above **does not** produce a new column in `iris` called `Sepal.Length2`...

One final and key advantage to the `tidyverse` paradigm, is that we can use **pipes** to make our code more succinct (see next section [below](#pipes)).

### Pipes (`%>%`) {#pipes}

> **Aside**: piping comes from Unix scripting, and simply means a chain of commands, such that the results from each command feed into the next one. 

Recently, the [`magrittr`](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) package, and subsequently `tidyverse` have introduced the pipe operator `%>%` that enables us to chain functions together. Let's look at an example:

```{r, eval = F}
iris %>% filter(Species == "versicolor")
```

```{r, echo = F}
iris %>% filter(Species == "versicolor") %>% head()
```

> **Notice**: when we did this before we would write something like `filter(iris, Species == "versicolor")` i.e. we required the first argument of `filter()` to be a `data.frame` (or `tibble`). The pipe operator `%>%` does this automatically, so the outcome from the left-hand side of the operator, is passed as the ***first*** argument to the right-hand side function. This makes the code more succinct, and easier to read (because we are not repeating pieces of code).

Pipes can be chained together multiple times. For example:

```{r, eval = F}
iris %>%
    filter(Species == "versicolor") %>%
    select(Species, starts_with("Sepal")) %>%
    mutate(Sepal.Length2 = Sepal.Length^2) %>%
    arrange(Sepal.Length)
```

```{r, echo = F}
iris %>%
    filter(Species == "versicolor") %>%
    select(Species, starts_with("Sepal")) %>%
    mutate(Sepal.Length2 = Sepal.Length^2) %>%
    arrange(Sepal.Length) %>%
    head()
```

I think this is neat! The code is written in a way that is much easier to understand, each part of the data wrangling process is chained together in an intuitive way (once you know the `tidyverse` functions of course). 

> In essence we can **read** what we have done in much the same way as if we were reading prose. Firstly we take the `iris` data, `filter` to extract just those rows corresponding to `versicolor` species, `select` species and speal measurements, `mutate` the data frame to contain a new column that is the square of the sepal lengths and finally `arrange` in order of increasing sepal length.
> 
> Notice that the pipe operator must be at the end of the line if we wish to split the code over multiple lines.

Try doing the same level of data cleaning in Excel as easily...

> **Note**: we can also pass the result of the right-hand side out using the assignment operator `<-` e.g. `iris <- iris %>% filter(Species = "versicolor")` would overwrite the `iris` data to produce a new data set with only `versicolor` entries. 

Once we've got our head around pipes, we can begin to use some of the other useful functions in `tidyverse` to do some really useful things.

> **Final point about pipes**: the package `magrittr` (on which the pipe is implemented) is more general than for just `tidyverse` functions. In fact, one can use the pipe to output any object from the left-hand side to the **first** argument of a function on the right-hand side of the pipe. This is really useful for using functions such as `summary()` or `head()`, that take data frame arguments. Hence I often use pipes like : `iris %>% filter(Species == "versicolor") %>% summary()`.
> 
> If you load the `magrittr` package, then there is much more you can do with these ideas. See [here](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) for a useful vignette.

### Grouping and summaries

A common thing we might want to do is to produce summaries of some variable for different subsets of the data. For example, we might want to produce an estimate of the mean of the sepal lengths for each species of iris. The `dplyr` package provides a function `group_by()` that allows us to group data, and `summarise()` that allows us to summarise data.

In this case we can think of "grouping" the data by `Species` and then averaging the `Sepal.Length` values within each group. Hence,

```{r}
iris %>% 
    group_by(Species) %>%
    summarise(mn = mean(Sepal.Length))
```

The `summarise()` function (note, this is different to the `summary()` function), applies a function to a `data.frame` or subsets of a `data.frame`. Think of it a bit like the `tapply` function, but with more consistent notation and more power.

```{task}
Produce a table of estimates for the mean *and* variance of both sepal lengths and widths, within each species.
```

```{solution}

``{r}
iris %>% 
    group_by(Species) %>%
    summarise(mnL = mean(Sepal.Length), varL = var(Sepal.Length),
              mnW = mean(Sepal.Width), varW = var(Sepal.Width))
``

```

## Reshaping data sets

Another key feature of `tidyverse` is the power it gives you to reshape data sets. The two key functions are `gather()` and `spread()`. The `gather()` function takes multiple columns, and gathers them into key-value pairs. The `spread()` function is its converse, it takes two columns (`key` and `value`) and spreads in to multiple columns. These ideas are best illustrated by an example.

### Example: Gapminder

Let's pull up some data. You should have access to a .csv file called "indicator gapminder gdp_per_capita_ppp.csv". This is a digital download of the [Gapminder](https://www.gapminder.org/) GDP per capita data that can be found in the `gapminder` package. All the data sets used in the [Gapminder](https://www.gapminder.org/) project can be downloaded from [https://www.gapminder.org/data/](https://www.gapminder.org/data/).

Download this file and save it into your working directory. Now let's read in the data using the `read_csv()` function in `tidyverse`[^2]

[^2]: Note that this is different than the `read.csv()` function in base R. It doesn't convert `character` columns to  `factor` columns, and returns a `tibble` by default.

```{r, message = F}
gp_income <- read_csv("indicator gapminder gdp_per_capita_ppp.csv")
gp_income
```

```{task}
Is this data in 'tidy' format?
```

```{solution}
No, this data is not in 'tidy' format. We can see that each row corresponds to a different `country`, but each column corresponds to a different `year`. For this to be 'tidy', we would need one column containing the `country`, one containing the `year`, and a third containing the GDP for each country in each year.
```

Before we go any further, notice that the first column is labelled incorrectly as `GDP per capita` (this is an artefact from the original data set), so let's rename the first column using the `rename()` function:

```{r}
gp_income <- gp_income %>%
    rename(country = `GDP per capita`)
gp_income
```

> **Note** that we can use backticks to enclose names that include spaces (which `read_csv()` allows).

Notice that the `rename()` function takes the same form as other `tidyverse` functions such as `filter()` or `arrange()`. We then overwrite the original data frame to keep our workspace neat.

> **Note**: this is OK here because we have a copy of our **raw** data saved in an external file. This, combined with the use of **scripts**, means we have a backup of the original data in case anything goes wrong. Don't overwrite your original data set!

The next thing we need to do is to collapse the **year** columns down. Ideally we want a column corresponding to **country**, a column corresponding to **year** and a final column corresponding to **GDP**. We are going to do this by using the `gather()` function. Note that the arguments to `gather()` are:

* `data`: this gives the name of the data frame;
* `key`: gives the name of the column that will contain the collapsed column names (e.g. `1800`, `1801` etc.);
* `value`: gives the name of the columns that will contain the **values** in each of the cells of the collapsed column (e.g. the corresponding GDP values);
* the final set of arguments correspond to those columns we wish to collapse. Here we want to collapse everything ***except*** `country`, which we can do using the `-` operator.

```{r}
gp_income <- gp_income %>%
    gather(key = year, value = gdp, -country)
gp_income
```

Great! This is almost there now. Notice that R has left the new `year` column as a `character` vector, so we want to change that:

```{r}
gp_income <- gp_income %>%
        mutate(year = as.numeric(year))
```

Also, there is quite a lot of extraneous information in the data. Firstly, there were some mostly empty rows in Excel, which manifest as missing values when the data were read into R:

```{r}
sum(is.na(gp_income$country))
```

We can examine these rows by filtering. 

```{r}
gp_income %>% filter(is.na(country)) %>% summary()
```

We can see from the summary that only one row has any GDP information, and indeed in the original data there was a single additional point that could be found in cell HE263 of the original Excel file. I think this is an artefact of the original data, and as such we will remove it here:

```{r}
gp_income <- gp_income %>% filter(!is.na(country))
```

We can also remove the rows that have no GDP information if we so wish (which are denoted by **missing values**---`NA`):

```{r}
gp_income <- gp_income %>% filter(!is.na(gdp))
```

Finally, we will restrict ourselves to looking at the data from 1990 onwards:

```{r}
gp_income <- gp_income %>% filter(year > 1990)
head(gp_income)
summary(gp_income)
```

Phew! this took some effort, but we've managed to end up with a fairly clean data set that we can plot, summarise etc.

To do all of the previous data cleaning operation using pipes, we can write:

```{r, message = F}
gp_income <- read_csv("indicator gapminder gdp_per_capita_ppp.csv") %>%
                rename(country = `GDP per capita`) %>%
                gather(year, gdp, -country) %>%
                mutate(year = as.numeric(year)) %>%
                filter(!is.na(country)) %>%
                filter(!is.na(gdp)) %>%
                filter(year > 1990)
```

Now we can begin to motor. For example, we might want to produce a mean GDP for each country, averaging over years. In this case we can think of "grouping" the data by country and then averaging the GDP values within each group (as we have seen before):

```{r}
gp_income %>% 
    group_by(country) %>%
    summarise(mn = mean(gdp))
```

```{task}
Produce the mean GDP for each year, averaged across countries.
```

```{solution}

``{r}
gp_income %>% 
    group_by(year) %>%
    summarise(mn = mean(gdp))
``

Notice that although `year` is a numerical variable, R can still group by unique values here.
```

We must be a bit careful here, since we may have less samples for some countries/years than for others. This affects the uncertainty in our estimates, though it is not too difficult to extract standard errors for each grouping and thus produce confidence intervals to quantify which estimates are more uncertain than others (this is where proper **statistical modelling** is paramount).

```{task}
Load in the file "indicator hiv estimated prevalence% 15-49.csv" that can be found on ELE. This file contains the estimated HIV **prevalence** in people of age 15--49 in different countries over time. **Prevalence** is defined here to be the estimated number of people living with HIV per 100 population. Produce a **tidy** data set called `gp_hiv` using the tools in `tidyverse` that we introduced above. The dataset needs to run from 1991 onwards, and we want to end up with columns `country`, `year` and `prevalence`. [Note that a couple of the years have no values in the data set, and by default R reads these columns in as `character` columns. Hence when you `gather()` the data to create a `prevalence` column, all the numbers will be converted into `characters`. One way to deal with this is to convert the column back into numbers once you have filtered away all the guff!]
```

```{solution}

``{r, message = F}
gp_hiv <- read_csv("indicator hiv estimated prevalence% 15-49.csv") %>%
            rename(country = `Estimated HIV Prevalence% - (Ages 15-49)`) %>%
            gather(year, prevalence, -country) %>%
            mutate(year = as.numeric(year)) %>%
            filter(!is.na(country)) %>%
            filter(!is.na(prevalence)) %>%
            filter(year > 1990) %>%
            mutate(prevalence = as.numeric(prevalence))
``

```

```{r, include = F}
gp_hiv <- readRDS("gp_hiv.rds")
```

```{task}
Produce a line plot of HIV prevalence over time for Uganda and Brazil. Use different colours for the different countries. [Use `ggplot2`, and notice that the first argument to the `ggplot()` function is a `data.frame`! You might also have to convert the `year` column to a `numeric`...]
```

```{solution}

``{r}
gp_hiv %>%
    filter(country == "Brazil" | country == "Uganda") %>%
    ggplot(aes(x = year, y = prevalence, colour = country)) +
        geom_line() + xlab("Year") + ylab("Prevalence") +
        guides(colour = guide_legend(title = "Country"))
``

```
    
## Joins

We now have two data sets: `gp_income` and `gp_hiv`. In order to visualise and analyse them, we need to link them together. A key skill to have in data manipulation is the ability to **join** data sets (or tables) together. The `dplyr` package provides various functions to do this, depending on ***how*** you want to join the tables.

> In case you haven't managed to complete the last task, the `gp_hiv` data is available as "gp_hiv.rds". You can read this into R using `gp_hiv <- readRDS("gp_hiv.rds")` and continue with the practical.

In order to join two tables, you must have one or more variables **in common**. In this case we want to match by `country` and `year`, to produce a data set that contains `country`, `year`, `gdp` and `prevalence`.

There should be *at most* one entry for each `country` $\times$ `year` combination. We can check this using the `count()` function in `dplyr`:

```{r}
gp_income %>% count(country, year) %>% summary()
gp_hiv %>% count(country, year) %>% summary()
```

> `count()` counts the numbers of entries in each combination of the provided variables: in this case `year` and `country`. The `summary()` function is to provide a straightforward way to see that all the `country` $\times$ `year` combinations have one entry only.

This should make it straightforward to join. Hence,

```{r}
gp <- inner_join(gp_income, gp_hiv, by = c("year", "country"))
gp
```

The `inner_join()` function takes two data sets, and returns a combined data set with entries that match on both `country` ***and*** `year`. Any rows from either data set that do not match the other data set are removed. To have a look at entries that differ on the matching criteria between the data sets, then we can use either `semi_join()` or `anti_join()` (please see [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)). For example, the function `anti_join(gp_income, gp_hiv, by = c("year", "country"))` will return all rows of `gp_income` that can't be matched to `gp_hiv`, abd visa-versa for `anti_join(gp_hiv, gp_income, by = c("year", "country"))`:

```{r}
anti_join(gp_income, gp_hiv, by = c("year", "country"))
anti_join(gp_hiv, gp_income, by = c("year", "country"))
```

We can see that there are `r nrow(anti_join(gp_income, gp_hiv, by = c("year", "country")))` entries present in `gp_income` that can't be matched to `gp_hiv`, but `r nrow(anti_join(gp_hiv, gp_income, by = c("year", "country")))` entries in `gp_hiv` that can't be matched to `gp_income`. 

### Types of join

> **Inner joins** return ***only*** those rows that can be matched in both data sets, it discards any rows from either data frame that can't be matched.

> **Outer joins** retain rows that don't match, depending on the type of join. **Left** outer joins retain rows from the left-hand side that don't match the right, but discard rows from the right that don't match the left. **Right** outer joins retain rows from the right-hand side that don't match the left, but discard rows from the left that don't match the right. **Full** outer joins return all rows that don't match. R uses missing values (`NA`) to fill in gaps that it can't match. For example,
> ```{r}
> left_join(gp_income, gp_hiv, by = c("year", "country"))
> ```
> Here we can see that there is no prevalence data for `Afghanistan` in `1991`, so R has included the row but with a missing value (`NA`) in place of the prevalence data. In the `inner_join` above, this row was removed. Try exploring **right-** and **full-** outer joins.
> ```{r}
> right_join(gp_income, gp_hiv, by = c("year", "country"))
> full_join(gp_income, gp_hiv, by = c("year", "country"))
> ```
> What do you notice about the **left-** and **full-** outer joins here? Why is this so?

We want to plot HIV prevalence against GDP per capita, and so an **inner join** is sufficient here.

> There is a great cheat sheet for joining that I found [here](http://stat545.com/bit001_dplyr-cheatsheet.html).

Hopefully we have now cleaned two data sets, merged them together and can now proceed with visualising them.

```{task}
Using `ggplot2`, produce a plot of HIV prevalence in 15-49 year olds against $\log_{10}$ (GDP per capita) for 1991, 1997, 2005 and 2011, where each point represents a `country`.
```

```{solution}

``{r}
## here is one solution using filtering, piping and faceting
gp %>%
    filter(year == 1991 | year == 1997 | year == 2005 | year == 2011) %>%
    ggplot(aes(x = gdp, y = prevalence)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    xlab("GDP per capita") +
    ylab("HIV prevalence in 15-49 year olds") +
    facet_wrap(~year)
``

```

```{task}
Total population data are available in the "indicator gapminder population.csv" document on ELE. Load this into R, tidy it up, and then join it to the `gp` data you have already created.
```

```{solution}

``{r, message = F}
## read in data
gp_pop <- read_csv("indicator gapminder population.csv") %>%
                gather(year, pop, -`Total population`) %>%
                rename(country = `Total population`) %>%
                mutate(year = as.numeric(year)) %>%
                filter(!is.na(country)) %>%
                filter(!is.na(pop)) %>%
                filter(year > 1990)

## check no population data are missing
## hence all rows of gp can be matched
anti_join(gp, gp_pop, by = c("year", "country"))

## join to gp table
gp <- inner_join(gp, gp_pop, by = c("year", "country"))
``

```

```{r, include = F}
gp_pop <- readRDS("gp_pop.rds")
gp <- readRDS("gp.rds")
```

```{task}
Produce a new plot of HIV prevalence against GDP per capita for 1991, 1997, 2005 and 2011, where each point represents a `country` and where the point sizes are scaled by population size.
```

```{solution}

``{r}
## here is one solution using filtering, piping and faceting
gp %>%
    mutate(year = as.numeric(year)) %>%
    filter(year == 1991 | year == 1997 | year == 2005 | year == 2011) %>%
    ggplot(aes(x = gdp, y = prevalence, size = pop)) +
    geom_point() + 
    scale_x_continuous(trans = "log10") +
    guides(size = guide_legend(title = "Population size")) +
    xlab("GDP per capita") +
    ylab("HIV prevalence in 15-49 year olds") +
    facet_wrap(~year)
``

```

